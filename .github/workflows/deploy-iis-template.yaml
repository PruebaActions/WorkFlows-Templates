name: Deploy IIS Template

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
      solution_path:
        required: true
        type: string
      iis_site_name:
        required: true
        type: string
      iis_root_path:
        required: true
        type: string
      has_sql_scripts:
        required: false
        type: boolean
        default: false
      sql_scripts_branch:
        required: false
        type: string
        default: ''
      sql_connection_string:
        required: false
        type: string
        default: ''

jobs:
  deploy_to_iis:
    name: "Build and Deploy to IIS"
    runs-on:
      group: IIS-Runners  # Tu grupo de self-hosted runners en Windows Server

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # üîç Detectar si es .NET Framework o .NET Core/5+
      - name: Detect .NET version
        id: detect
        shell: pwsh
        run: |
          $sln = "${{ inputs.solution_path }}"
          $content = Get-Content $sln -Raw
          if ($content -match "TargetFrameworkVersion") {
            echo "framework=netframework" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            echo "framework=netcore" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      # üß± Compilar y publicar
      - name: Build and Publish
        id: build
        shell: pwsh
        run: |
          $publishDir = "$env:GITHUB_WORKSPACE\publish"
          if (Test-Path $publishDir) { Remove-Item $publishDir -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $publishDir | Out-Null

          if ("${{ steps.detect.outputs.framework }}" -eq "netframework") {
            Write-Host "Building .NET Framework app..."
            & "C:\Program Files\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\MSBuild.exe" "${{ inputs.solution_path }}" /p:Configuration=Release /p:DeployOnBuild=true /p:PublishUrl=$publishDir
          } else {
            Write-Host "Building .NET (Core/5+) app..."
            dotnet publish "${{ inputs.solution_path }}" --configuration Release --output $publishDir
          }

      # üóìÔ∏è Generar carpeta versionada (APP-YYYY-MM-DD-#)
      - name: Generate deployment version
        id: version
        shell: pwsh
        run: |
          $date = Get-Date -Format "yyyy-MM-dd"
          $base = "${{ inputs.app_name }}-$date"
          $root = "${{ inputs.iis_root_path }}"
          $count = (Get-ChildItem "$root" -Directory | Where-Object { $_.Name -like "$base*" }).Count + 1
          $newVersion = "$base-$count"
          echo "new_version=$newVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # ‚öôÔ∏è Ejecutar scripts SQL (opcional)
      - name: Run SQL scripts
        if: ${{ inputs.has_sql_scripts }}
        shell: pwsh
        run: |
          git fetch origin ${{ inputs.sql_scripts_branch }}
          git checkout ${{ inputs.sql_scripts_branch }}
          $scripts = Get-ChildItem -Path "./" -Filter "*.sql" | Sort-Object Name
          foreach ($script in $scripts) {
            Write-Host "Executing $($script.Name)"
            sqlcmd -S "(local)" -E -i $script.FullName
          }

      # üíæ Backup del deployment actual
      - name: Backup current version
        shell: pwsh
        run: |
          $source = Join-Path "${{ inputs.iis_root_path }}" "${{ inputs.app_name }}"
          if (-not (Test-Path $source)) {
            Write-Host "No existing deployment found, skipping backup."
            exit 0
          }
          $backup = "C:\inetpub\backups\${{ steps.version.outputs.new_version }}"
          New-Item -ItemType Directory -Force -Path $backup | Out-Null
          Copy-Item "$source\*" $backup -Recurse -Force
          echo "backup_path=$backup" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # üöÄ Desplegar con Web Deploy
      - name: Deploy new version
        id: deploy
        shell: pwsh
        continue-on-error: true
        run: |
          $publishDir = "$env:GITHUB_WORKSPACE\publish"
          $target = "C:\inetpub\wwwroot\${{ steps.version.outputs.new_version }}"
          New-Item -ItemType Directory -Force -Path $target | Out-Null
          $cmd = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
          & $cmd -verb:sync `
                 -source:contentPath:"$publishDir" `
                 -dest:contentPath:"$target",computerName=localhost `
                 -enableRule:AppOffline `
                 -retryAttempts:3 `
                 -allowUntrusted
          if ($LASTEXITCODE -ne 0) { exit 1 }

      # ü©∫ Health Check del sitio
      - name: Health check
        id: health
        continue-on-error: true
        shell: pwsh
        run: |
          $url = "http://localhost/"
          try {
            $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -ne 200) { exit 1 }
          } catch {
            Write-Host "Health check failed."
            exit 1
          }

      # üîÅ Swap IIS site si el health check pasa
      - name: Swap IIS site path
        if: ${{ steps.deploy.outcome == 'success' && steps.health.outcome == 'success' }}
        shell: pwsh
        run: |
          Import-Module WebAdministration
          Set-ItemProperty "IIS:\Sites\${{ inputs.iis_site_name }}" -Name physicalPath -Value "C:\inetpub\wwwroot\${{ steps.version.outputs.new_version }}"
          iisreset

      # ‚è™ Rollback autom√°tico si algo falla
      - name: Automatic rollback
        if: ${{ steps.deploy.outcome == 'failure' || steps.health.outcome == 'failure' }}
        shell: pwsh
        run: |
          Write-Host "‚ö†Ô∏è Deployment failed or health check failed. Rolling back..."
          Import-Module WebAdministration
          $backup = "C:\inetpub\backups\${{ steps.version.outputs.new_version }}"
          if (Test-Path $backup) {
            $livePath = "C:\inetpub\wwwroot\${{ inputs.app_name }}"
            if (Test-Path $livePath) { Remove-Item $livePath -Recurse -Force }
            Copy-Item "$backup\*" $livePath -Recurse -Force
            Set-ItemProperty "IIS:\Sites\${{ inputs.iis_site_name }}" -Name physicalPath -Value $livePath
            iisreset
          } else {
            Write-Host "No backup found for rollback."
          }
