name: Deploy IIS Template

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
      solution_path:
        required: true
        type: string
      iis_site_name:
        required: true
        type: string
      iis_root_path:
        required: true
        type: string
      framework_type:   # üëà NUEVO par√°metro
        required: true
        type: string
        description: "Tipo de framework: netframework o netcore"
      has_sql_scripts:
        required: false
        type: boolean
        default: false
      sql_scripts_branch:
        required: false
        type: string
        default: ''
      sql_connection_string:
        required: false
        type: string
        default: ''

jobs:
  deploy_to_iis:
    name: "Build and Deploy to IIS"
    runs-on:
      group: DAST

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # üß± Compilar y publicar seg√∫n el tipo de framework
      - name: Build and Publish
        id: build
        shell: powershell
        run: |
          $publishDir = "$env:GITHUB_WORKSPACE\publish"
          if (Test-Path $publishDir) { Remove-Item $publishDir -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $publishDir | Out-Null

          $framework = "${{ inputs.framework_type }}"
          Write-Host "Detected framework from input: $framework"

          if ($framework -eq "netframework") {
            Write-Host "üß± Building ASP.NET Framework app with MSBuild..."
            $msbuild = "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\MSBuild.exe"
            $nugetPath = "C:\Tools\nuget\nuget.exe"

            if (-not (Test-Path $msbuild)) {
              Write-Host "‚ùå MSBuild not found at $msbuild"
              exit 1
            }
            if (-not (Test-Path $nugetPath)) {
              Write-Host "‚ùå nuget.exe not found at $nugetPath"
              exit 1
            }

            # üîπ Restaurar paquetes NuGet
            Write-Host "üì¶ Restoring NuGet packages..."
            & $nugetPath restore "${{ inputs.solution_path }}" -NonInteractive -Verbosity detailed
            if ($LASTEXITCODE -ne 0) {
              Write-Host "‚ùå NuGet restore failed."
              exit 1
            }

            # üîπ Compilar con MSBuild
            Write-Host "üöÄ Starting MSBuild..."
            & $msbuild "${{ inputs.solution_path }}" `
              /p:Configuration=Release `
              /p:DeployOnBuild=true `
              /p:WebPublishMethod=FileSystem `
              /p:DeleteExistingFiles=False `
              /p:PublishUrl="$publishDir" `
              /verbosity:minimal `
              /t:Build

            if ($LASTEXITCODE -ne 0) {
              Write-Host "‚ùå MSBuild build failed."
              exit 1
            }

          } elseif ($framework -eq "netcore") {
            Write-Host "üß± Building .NET (Core/5+) app..."
            dotnet restore "${{ inputs.solution_path }}"
            $projects = Get-ChildItem -Path (Split-Path "${{ inputs.solution_path }}") -Filter "*.csproj" -Recurse
            foreach ($proj in $projects) {
              dotnet publish $proj.FullName --configuration Release --output "$publishDir\$($proj.BaseName)"
            }
          } else {
            Write-Host "‚ùå Invalid framework_type. Must be 'netframework' or 'netcore'."
            exit 1
          }

          Write-Host "‚úÖ Build and publish completed at: $publishDir"
          Get-ChildItem $publishDir -Recurse | Select-Object FullName


      # üóìÔ∏è Generar carpeta versionada (APP-YYYY-MM-DD-#)
      - name: Generate deployment version
        id: version
        shell: powershell
        run: |
          $date = Get-Date -Format "yyyy-MM-dd"
          $base = "${{ inputs.app_name }}-$date"
          $root = "${{ inputs.iis_root_path }}"
          $count = (Get-ChildItem "$root" -Directory | Where-Object { $_.Name -like "$base*" }).Count + 1
          $newVersion = "$base-$count"
          echo "new_version=$newVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # ‚öôÔ∏è Ejecutar scripts SQL (opcional)
      - name: Run SQL scripts
        if: ${{ inputs.has_sql_scripts }}
        shell: powershell
        run: |
          git fetch origin ${{ inputs.sql_scripts_branch }}
          git checkout ${{ inputs.sql_scripts_branch }}
          $scripts = Get-ChildItem -Path "./" -Filter "*.sql" | Sort-Object Name
          foreach ($script in $scripts) {
            Write-Host "Executing $($script.Name)"
            sqlcmd -S "(local)" -E -i $script.FullName
          }

      # üíæ Backup del deployment actual
      - name: Backup current version
        shell: powershell
        run: |
          $source = Join-Path "${{ inputs.iis_root_path }}" "${{ inputs.app_name }}"
          if (-not (Test-Path $source)) {
            Write-Host "No existing deployment found, skipping backup."
            exit 0
          }
          $backup = "C:\inetpub\backups\${{ steps.version.outputs.new_version }}"
          New-Item -ItemType Directory -Force -Path $backup | Out-Null
          Copy-Item "$source\*" $backup -Recurse -Force
          echo "backup_path=$backup" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # üöÄ Desplegar con Web Deploy
      - name: Deploy new version
        id: deploy
        shell: powershell
        continue-on-error: true
        run: |
          $publishDir = "$env:GITHUB_WORKSPACE\publish"
          $target = "C:\inetpub\wwwroot\${{ steps.version.outputs.new_version }}"
          New-Item -ItemType Directory -Force -Path $target | Out-Null
          $cmd = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"

          & $cmd -verb:sync `
                 -source:contentPath:"$publishDir" `
                 -dest:contentPath:"$target",computerName=localhost `
                 -enableRule:AppOffline `
                 -retryAttempts:3 `
                 -allowUntrusted

          if ($LASTEXITCODE -ne 0) { exit 1 }

      # ü©∫ Health Check del sitio
      - name: Health check
        id: health
        continue-on-error: true
        shell: powershell
        run: |
          $url = "http://localhost/"
          try {
            $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -ne 200) { exit 1 }
          } catch {
            Write-Host "Health check failed."
            exit 1
          }

      # üîÅ Swap IIS site si el health check pasa
      - name: Swap IIS site path
        if: ${{ steps.deploy.outcome == 'success' && steps.health.outcome == 'success' }}
        shell: powershell
        run: |
          Import-Module WebAdministration
          Set-ItemProperty "IIS:\Sites\${{ inputs.iis_site_name }}" -Name physicalPath -Value "C:\inetpub\wwwroot\${{ steps.version.outputs.new_version }}"
          iisreset

      # ‚è™ Rollback autom√°tico si algo falla
      - name: Automatic rollback
        if: ${{ steps.deploy.outcome == 'failure' || steps.health.outcome == 'failure' }}
        shell: powershell
        run: |
          Write-Host "‚ö†Ô∏è Deployment failed or health check failed. Rolling back..."
          Import-Module WebAdministration
          $backup = "C:\inetpub\backups\${{ steps.version.outputs.new_version }}"
          if (Test-Path $backup) {
            $livePath = "C:\inetpub\wwwroot\${{ inputs.app_name }}"
            if (Test-Path $livePath) { Remove-Item $livePath -Recurse -Force }
            Copy-Item "$backup\*" $livePath -Recurse -Force
            Set-ItemProperty "IIS:\Sites\${{ inputs.iis_site_name }}" -Name physicalPath -Value $livePath
            iisreset
          } else {
            Write-Host "No backup found for rollback."
          }
