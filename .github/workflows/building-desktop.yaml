name: Build ClickOnce Template

on:
  workflow_call:
    secrets:
      CERT_PASSWORD_SALES:
        required: false
    inputs:
      # assemblyVersion:
      #   type: string
      #   required: false
      # publishDir:
      #   type: string
      #   required: false
      # installUrl:
      #   type: string
      #   required: false
      # project_path:
      #   type: string
      #   required: false
      # sln_path:
      #   type: string
      #   required: false
      # appConfigPath:
      #   type: string
      #   required: false
      # assemblyInfo_path:
      #   type: string
      #   required: false
      # dest_appConfig_path:
      #   type: string
      #   required: false
      # msi_project_path:
      #   required: false
      #   type: string
      # cert_path:
      #   required: false
      #   type: string
      projects_json:
        required: false
        type: string
      runner_tag:
        required: false
        type: string
      skip_items_json:
        description: "JSON array of files/folders to skip during msdeploy"
        required: false
        default: "[]"
        type: string
      project_compile_info_json:
        required: false
        type: string

jobs:
  # sql_scripts_execution:
  #   name: "Checkout SQL branch and list files"
  #   runs-on:
  #     group: DAST
  #   steps:
  #     - name: Checkout Sql branch
  #       uses: actions/checkout@v4
  #       with:
  #         ref: Sql

  #     - name: List files in Sql branch
  #       shell: bash
  #       run: |
  #         echo "Listing files in Sql branch..."
  #         ls -R .
          
  build_clickonce:
    name: "Modify Files & Build ClickOnce"
    runs-on:
        group: DAST
    strategy:
      matrix: ${{ fromJson(inputs.project_compile_info_json) }}
      max-parallel: 1
    env:
      CERT_PASSWORD_SALES: ${{ secrets.CERT_PASSWORD_SALES }}
    # needs: sql_scripts_execution
    # if: ${{ needs.sql_scripts_execution.outputs.success == 'true' }}

    steps:
      - name: Checkout current branch
        uses: actions/checkout@v4
        # with:
        #   ref: ${{ github.ref_name }}

      - name: Generate dynamic version
        id: version
        shell: powershell
        run: |
          $today = Get-Date -Format "yyyy.MM.dd"
          $runCounterFile = "$env:GITHUB_WORKSPACE/.run-counter"

          if (Test-Path $runCounterFile) {
          $lastLine = Get-Content $runCounterFile | Select-Object -Last 1
          $parts = $lastLine -split '\.'
          $lastDate = ($parts[0..2] -join '.')
          $lastRun = [int]$parts[3]

          if ($lastDate -eq $today) {
            $runNumber = $lastRun + 1
          } else {
            $runNumber = 1
          }
          } else {
          $runNumber = 1
          }

          $version = "$today.$runNumber"
          Write-Host "Generated version: $version"

          # Sobrescribe el archivo con la √∫ltima versi√≥n generada
          $version | Out-File -FilePath $runCounterFile -Encoding UTF8

          # Exporta la variable al pipeline
          echo "appVersion=$version" >> $env:GITHUB_OUTPUT

      - name: Replace App.config
        shell: powershell
        run: |
          $source = "${{ matrix.appConfigPath }}"
          $destination = "${{ matrix.dest_appConfig_path }}"

          if (Test-Path $source) {
            Write-Host "Replacing App.config with $source"
            Copy-Item -Path $source -Destination $destination -Force
          } else {
            Write-Error "App.config not found: $source"
            exit 1
          }

      - name: Update AssemblyInfo version
        shell: powershell
        run: |
          $assemblyInfo = "${{ matrix.assemblyInfo_path }}"
          $assemblyVersion = "${{ matrix.assemblyVersion }}"
          $appVersion = "${{ steps.version.outputs.appVersion }}"
          Write-Host "Updating AssemblyVersion to $assemblyVersion"
          Write-Host "Updating FileVersion to $appVersion"

          (Get-Content $assemblyInfo) |
            ForEach-Object {
              $_ -replace 'AssemblyVersion\(".*"\)', "AssemblyVersion(`"$assemblyVersion`")" `
                 -replace 'AssemblyFileVersion\(".*"\)', "AssemblyFileVersion(`"$appVersion`")"
            } | Set-Content $assemblyInfo

      - name: Validate publish directory
        shell: powershell
        run: |
          if (-not (Test-Path "${{ matrix.publishDir }}")) {
            Write-Host "Creating publish directory..."
            New-Item -ItemType Directory -Force -Path "${{ matrix.publishDir }}"
          }

      - name: Restore NuGet packages
        run: nuget restore "${{ matrix.sln_path }}"

      - name: Build and Publish ClickOnce
        shell: powershell
        run: |
          #$certPath = Resolve-Path '${{ matrix.cert_path }}'
          #$certPasswordPlain = "${{ secrets.CERT_PASSWORD_SALES }}"
          #$securePassword = ConvertTo-SecureString $certPasswordPlain -AsPlainText -Force
          $appVersion = '${{ steps.version.outputs.appVersion }}'

          # Write-Host "Importing certificate from $certPath..."
          # $importedCert = Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
          # if (-not $importedCert) {
          #   Write-Error "Certificate import failed."
          #   exit 1
          # }

          # $thumbprint = $importedCert.Thumbprint
          # $subject = $importedCert.Subject
          # Write-Host "Imported certificate: $subject"
          # Write-Host "Thumbprint: $thumbprint"

          Start-Sleep -Seconds 5

          Write-Host "Building ClickOnce package with version $appVersion"

          msbuild '${{ matrix.project_path }}' `
            /t:Publish `
            /p:Configuration='Release' `
            /p:Platform='Any CPU' `
            /p:PublishDir='${{ matrix.publishDir }}' `
            /p:InstallUrl='${{ matrix.installUrl }}' `
            /p:ApplicationVersion="$appVersion" `
            /p:MinimumRequiredVersion="$appVersion" `
            /p:OutputPath='bin\Release' `
            /v:minimal 
            # /p:SignManifests=true `
            # /p:ManifestKeyFile= `
            # /p:ManifestKeyPassword= `
            # /p:ManifestCertificateStoreName="My" `
            # /p:ManifestCertificateSubjectName="$subject" `
            # /p:ManifestCertificateThumbprint="$thumbprint" `
            

      - name: Update MSI Version and GUIDs
        shell: pwsh
        run: |
          $vdprojPath = '${{ matrix.msi_project_path }}'
          $fullVersion = '${{ steps.version.outputs.appVersion }}'

          if (-not (Test-Path $vdprojPath)) {
            Write-Error "‚ùå No se encontr√≥ el archivo .vdproj en la ruta $vdprojPath"
            exit 1
          }

          Write-Host "üîç Actualizando versi√≥n del MSI usando: $fullVersion"

          # Extraer partes de la versi√≥n
          $parts = $fullVersion -split '\.'
          if ($parts.Length -lt 3) {
            Write-Error "‚ö†Ô∏è Formato de versi√≥n inesperado: $fullVersion"
            exit 1
          }

          $shortYear = $parts[0][-2..-1] -join ''   # "25"
          $month = $parts[1].PadLeft(2, '0')        # "11"
          $day = $parts[2].PadLeft(2, '0')          # "20"
          $run = if ($parts.Length -ge 4) { $parts[3] } else { "1" }

          # Nueva l√≥gica ‚Üí √∫ltimo bloque combina d√≠a + corrida ("201" en lugar de "001")
          $lastBlock = ("{0}{1:D2}" -f $day, [int]$run)  # ej: "20" + "01" = "2001" ‚Üí truncamos si excede 3
          if ($lastBlock.Length -gt 3) { $lastBlock = $lastBlock.Substring(0,3) }

          $newVersion = "$shortYear.$month.$lastBlock"
          Write-Host "üß© Nueva versi√≥n MSI: $newVersion"

          # Generar nuevos GUIDs
          $newProductCode = [guid]::NewGuid().ToString().ToUpper()
          $newPackageCode = [guid]::NewGuid().ToString().ToUpper()

          Write-Host "üÜï ProductCode: {$newProductCode}"
          Write-Host "üÜï PackageCode: {$newPackageCode}"

          # Leer y reemplazar en el archivo .vdproj
          $content = Get-Content $vdprojPath -Raw

          $content = $content -replace '"ProductVersion" = "8:[^"]+"', "`"ProductVersion`" = `"8:$newVersion`""
          $content = $content -replace '"ProductCode" = "8:{[^}]+}"', "`"ProductCode`" = `"8:{$newProductCode}`""
          $content = $content -replace '"PackageCode" = "8:{[^}]+}"', "`"PackageCode`" = `"8:{$newPackageCode}`""

          $content | Set-Content $vdprojPath -Encoding UTF8

          Write-Host "‚úÖ Archivo .vdproj actualizado correctamente"
          Write-Host "üì¶ ProductVersion: $newVersion"
          Write-Host "üß± ProductCode y PackageCode regenerados"


  #     - name: Build MSI Installer
  #       shell: powershell
  #       run: |
  #         # Ruta absoluta al devenv.com (necesario para buildear .vdproj)
  #         $devenv = "C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\devenv.com"

  #         if (-not (Test-Path $devenv)) {
  #           Write-Error "Visual Studio 2022 Community con Installer Projects no est√° instalado."
  #           exit 1
  #         }

  #         # Rutas
  #         $slnPath = (Resolve-Path "${{ matrix.sln_path }}").Path
  #         $msiPath = (Resolve-Path "${{ matrix.msi_project_path }}").Path
  #         $outputDir = "C:\test\msi"

  #         Write-Host "Building MSI from $projectPath"
  #         New-Item -ItemType Directory -Force -Path $outputDir | Out-Null

  #         # Ejecutar build del proyecto MSI
  #         & "$devenv" "$slnPath" /Build "Release" /Project $msiPath

  #         if ($LASTEXITCODE -ne 0) {
  #           Write-Error "MSI build failed."
  #           exit 1
  #         }

  #         Write-Host "MSI successfully built. Contents:"
  #         Get-ChildItem -Path $outputDir -Filter *.msi -Recurse | Select-Object FullName
            
  #     - name: Upload ClickOnce artifact
  #       uses: actions/upload-artifact@v4
  #       env:
  #         NODE_TLS_REJECT_UNAUTHORIZED: '0'
  #       with:
  #         name: ClickOnce-Package
  #         path: |
  #           ${{ matrix.publishDir }}/**
  #         if-no-files-found: error

      
  #     - name: Navegando MSI installer path
  #       shell: powershell
  #       id: find_msi
  #       run: |
  #         # Derivar carpeta base del proyecto MSI
  #         $msiProjectPath = "${{ matrix.msi_project_path }}"
  #         $msiDir = Split-Path $msiProjectPath -Parent
  #         $releaseDir = Join-Path $msiDir "Release"

  #         Write-Host "Searching for MSI files in: $releaseDir"

  #         if (-not (Test-Path $releaseDir)) {
  #           Write-Error "Release directory not found: $releaseDir"
  #           exit 1
  #         }

  #         $msiFiles = Get-ChildItem -Path $releaseDir -Filter *.msi -Recurse
  #         if (-not $msiFiles) {
  #           Write-Error "No MSI files found in $releaseDir"
  #           exit 1
  #         }

  #         Write-Host "Found the following MSI files:"
  #         $msiFiles | ForEach-Object { Write-Host " - $($_.FullName)" }

  #         echo "releaseDir=$releaseDir" >> $env:GITHUB_OUTPUT

  #     - name: Upload MSI artifact
  #       uses: actions/upload-artifact@v4
  #       env:
  #         NODE_TLS_REJECT_UNAUTHORIZED: '0'
  #       with:
  #         name: MSI-Installer
  #         path: |
  #           ${{ steps.find_msi.outputs.releaseDir }}/*.msi
  #         if-no-files-found: error

  # backup_installers:
  #   name: "üóÇÔ∏è Backup Installers"
  #   runs-on: ${{ fromJson(inputs.runner_tag) }}
  #   needs: build_clickonce
  #   strategy:
  #     matrix: ${{ fromJson(inputs.projects_json) }}
  #     max-parallel: 1
  #   steps:
  #     - name: "Prepare Backup Folder"
  #       uses: PruebaActions/WorkFlows-Templates/.github/actions/create-backup@main
  #       with:
  #         deploy_target_path: ${{ matrix.deploy_target_path }}

  # deploy_installers:
  #   name: "üöÄ Deploy Installers"
  #   needs: backup_installers
  #   runs-on: ${{ fromJson(inputs.runner_tag) }}
  #   strategy:
  #     matrix: ${{ fromJson(inputs.projects_json) }}
  #     max-parallel: 1

  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: "Downloading artifacts"
  #       uses: actions/download-artifact@v4
  #       env:
  #         NODE_TLS_REJECT_UNAUTHORIZED: '0'
  #       with:
  #         name: ${{ matrix.artifact_name}}
  #         path: ${{ github.workspace }}/artifact/${{ matrix.artifact_name}}

  #     - name: "Deploy to IIS"
  #       uses: PruebaActions/WorkFlows-Templates/.github/actions/deploy-to-iis@main
  #       with:
  #         project_name: ${{ matrix.project_name }}
  #         publish_path: ${{ github.workspace }}/artifact/${{ matrix.artifact_name }}
  #         destination_path: ${{ matrix.deploy_target_path }}
  #         skip_items_json: ${{ inputs.skip_items_json }}

      
